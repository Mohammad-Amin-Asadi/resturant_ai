####### Global Parameters #########

log_level=4
stderror_enabled=yes
syslog_enabled=no

socket=udp:*:5060

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/opensips/modules/"

loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "sipmsgops.so"
loadmodule "signaling.so"
loadmodule "cfgutils.so"
loadmodule "mi_fifo.so"
loadmodule "proto_tcp.so"
loadmodule "proto_udp.so"
loadmodule "sl.so"
loadmodule "event_datagram.so"
loadmodule "mi_datagram.so"
loadmodule "b2b_entities.so"
loadmodule "maxfwd.so"

modparam("mi_fifo", "fifo_name", "/tmp/opensips_fifo")

modparam("tm", "fr_timeout", 10)
modparam("tm", "fr_inv_timeout", 60)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "onreply_avp_mode", 1)

# MI datagram socket - engine connects to this
# If OpenSIPS is in Docker: use 0.0.0.0 to listen on all interfaces
modparam("mi_datagram", "socket_name", "udp:0.0.0.0:8080")

####### Routing Logic ########

startup_route {
    # Subscribe to E_UA_SESSION events and send them to engine
    # If OpenSIPS is in Docker: use service name (avatabot-engine:5061)
    # If OpenSIPS is on host: use 127.0.0.1:5061 (exposed port)
    if (!subscribe_event("E_UA_SESSION", "udp:avatabot-engine:5061")) {
        xlog("L_ERR", "Failed to subscribe to E_UA_SESSION events\n");
    } else {
        xlog("L_INFO", "Successfully subscribed to E_UA_SESSION events, sending to engine at avatabot-engine:5061\n");
    }
}

route {
    xlog("L_INFO", "========== NEW REQUEST ==========\n");
    xlog("L_INFO", "Method: $rm\n");
    xlog("L_INFO", "Request-URI (DID): $ru\n");
    xlog("L_INFO", "From: $fu\n");
    xlog("L_INFO", "To: $tu\n");
    xlog("L_INFO", "Source: $si:$sp\n");
    xlog("L_INFO", "================================\n");

    # Max forwards
    if (!mf_process_maxfwd_header(10)) {
        send_reply(483, "Too Many Hops");
        exit;
    }

    # Handle OPTIONS
    if (is_method("OPTIONS")) {
        xlog("L_INFO", "OPTIONS request - sending 200 OK\n");
        send_reply(200, "OK");
        exit;
    }

    # Handle ACK
    if (is_method("ACK")) {
        xlog("L_INFO", "ACK received\n");
        if (t_check_trans()) {
            t_relay();
        }
        exit;
    }

    # Handle CANCEL
    if (is_method("CANCEL")) {
        xlog("L_INFO", "CANCEL received\n");
        if (t_check_trans()) {
            t_relay();
        }
        exit;
    }

    # Handle sequential requests (within dialog)
    if (has_totag()) {
        xlog("L_INFO", "Sequential request detected\n");
        
        if (loose_route()) {
            if (is_method("BYE")) {
                xlog("L_INFO", "BYE request\n");
            }
            t_relay();
        } else {
            if (is_method("ACK")) {
                exit;
            }
            send_reply(404, "Not Found");
        }
        exit;
    }

    # Handle initial INVITE
    if (is_method("INVITE")) {
        xlog("L_INFO", "Initial INVITE - starting B2B session\n");
        
        record_route();
        
        # Save transaction before initializing B2B session
        if (!t_newtran()) {
            xlog("L_ERR", "Failed to create new transaction\n");
            send_reply(500, "Internal Server Error");
            exit;
        }
        
        ua_session_server_init($var(b2b_key), "rbh");
        xlog("L_INFO", "B2B session started with key: $var(b2b_key)\n");
        
        exit;
    }

    # Default: Method not allowed
    xlog("L_WARN", "Unsupported method: $rm\n");
    send_reply(405, "Method Not Allowed");
    exit;
}
